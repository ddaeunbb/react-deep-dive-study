# 1.1 자바스크립트 동등비교

- 리액트 컴포넌트의 렌더링이 일어나느 이유 줄 하나가 바로 props의 동등비교
- props의 동등비교는 객체의 얕은 비교를 기반으로 한다.
  - 해당 과정을 제대로 이해 못하면 최적화에 어려움을 겪게 된다.
- 가상 DOM과 실제 DOM을 비교할 때, 컴포넌트가 렌더링을 할지 판단하는 법, 변수나 함수의 메모이제이션 등 모든 작업은 JS의 동등비교를 기반으로 한다.

## 1.1.1 JS의 데이터 타입

JS의 모든 값은 데이터 타입을 가지고 있으며 크게 원시와 객체 타입으로 나뉜다.

### 원시 타입

객체가 아닌 모든 타입이다.

1. undefined
   <br/> 선언 후 값을 할당하지 않은 변수 OR 갑이 주어지지 않은 인수에 자동으로 할당되는 값
2. null
   <br/> 아직 값이 없거나 비어있는 값을 표현할 때 사용하는 값으로, 다른 원시값과 다르게 typeof 로 확인하면 Object 이다. 이는 초창기 JS가 값을 표현하는 방식 때문인데, 이후 이를 null로 바꾸려니 Breaking Change라서 기각되었다.

> - undefined와 null은 다른 원시타입 데이터들과 달리 가질 수 있는 값이 각각 null, undefined 뿐이다. 다른 원시타입 데이터들은 2개 이상 가질 수 있다. (boolean은 true, false)
> - undefined는 선언됐지만 할당되지 않은 값이고 null은 명시적으로 비어있음을 나타내는 값이다.

3. boolean
   <br/> 참과 거짓. 즉 true와 false 만을 가질 수 있는 데이터 타입.
   <br/> true나 false 이외에도 마치 이처럼 취급되는 truthy, falsy값이 존재한다.
   <br/> falsy한 값의 실제 타입 - false(Boolean) / NaN(Number) / null(null) / 0, -0, 0n, 0x0n(Number, Bigint) / undefined(undefined) / "", '', `` (String) - falsy값 이외에는 전부 truthy 값이다. 한가지 유의점은 {}와 []도 truthy하다는 점!

4. Number

- 정수, 실수를 구분하는 다른 언어와 다르게 JS는 모든 숫자를 하나의 타입에 저장한다. (현재는 Bigint타입도 있다.)
- 진수별로 값을 표현해도 모두 10진수로 해석되어 동일하게 표시된다.

5. BigInt

- number가 다룰 수 있는 숫자의 크기 제한을 극복하기 위해 ES2020에서 등장. 더 큰 범위의 숫자를 저장할 수 있다.

6. String

- 텍스트타입('), ("), 내장 표현식을 허용하는 문자열 리터럴 방식(`)
- 백틱을 사용한 문자열을 템플릿 리터럴이라고 하는데 줄바꿈이 가능하고 내부에 표현식 작성이 가능하다.
- JS의 문자열은 원시타입이기 때문에 한번 생성되면 그 문자열은 변경할 수 없다.

7. symbol

- ES6에서 추가된 7번째 원시타입으로 중복되지 않는 고유한 값을 나타내기 위해 사용.
- symbol은 symbol 함수를 사용해서만 만들 수 있다. (symbol())

### 객체 타입

앞선 7가지 원시타입을 제외한 모든 것. 즉 JS 이루고 있는 대부분의 타입이라 할 수있다. (배열, 함수, 정규식, 클래스 등) 이 객체 타입은 참조타입이라고도 불린다.

## 1.1.2 값을 저장하는 방식의 차이

원시 타입과 객체 타입의 가장 큰 차이는 값을 저장하는 방식이다. 이 차이가 동등 비교시에 차이는 만드는 원인이 된다.

- 원시 타입의 데이터는 '불변 형태'로 저장된다. 즉 할당 시점에 메모리 영억을 차지하고 저장된다.
- 객체는 프로퍼티를 삭제, 추가, 수정할 수 있으므로 '가변 상태'로 저장된다. 값을 복사할 때에도 값이 아닌 참조를 전달한다.
  - 즉 동일하게 선언했던 객체라 하더라도 저장하는 순간 다른 참조를 바라봐서 비교시 false가 뜬다.

**따라서 JS개발자는 항상 객체간 비교가 발생 시, 내부의 값이 같더라도 결과는 대부분 true가 아닐 수 있다는 것을 인지해야 한다.**

## 1.1.3 자바스크립트의 또 다른 비교 공식, Object.is

JS에서 비교를 위해서 제공하는 또 하나의 방법으로 두개의 인수를 받고 두개가 동일한지 반환하는 메서드이다.
<br/>Object.is에서 == 는 일반적인 === 처럼 타입이 다를 경우 false가 뜬다. Object.is에서의 === 역시 아래 예시 코드에서 알 수 있듯이 좀 더 개발자가 기대하는 방식으로 정확하게 비교해 준다.

```js
-0 === +0; // true
Object.is(-0, +0); // false

Number.NaN === NaN; // false
Object.is(Number.NaN, NaN); // true

NaN === 0 / 0; // false
Object.is(NaN, 0 / 0); // true
```

**즉 몇가지 특별 사항에서 동등 비교 ==와 ===가 가지는 한계 극복을 위해 만들어 졌으나, <br/>여전히 객체 간 비교는 JS의 특징으로 인해서 ===와 동일하게 동작한다.**

## 1.1.4 리액트에서의 동등비교

리액트가 사용하는 동등비교는 ==나 ===가 아닌, Object.is이다. 리액트에서는 이 Onject.is를 기반으로 동등비교를 하는 shallowEqual이라는 함수를 만들어서 사용한다. 이 함수는 의존성 비교 등 리액트의 동등비교가 필요한 다양한 곳에서 사용된다.

- Object.is로 먼저 비교를 수행한 후에 Object.is에서 수행하지 못하는 비교, 즉 객체 간 얕은 비교(객체의 첫번째 깊이에 존재하는 값만 비교)를 한번 더 수행한다.

- 객체의 얕은 비교만 구현한 이유는?
  - 기본적으로 리액트는 props에서 꺼내온 값을 기준으로 렌더링을 수행한다. 따라서 일반적 케이스에서는 얕은 비교로 충분하다. props에 또 다른 객체를 넘겨주면 렌더링이 예상치 못하게 작동한다.

JS에서 객체 비교의 불완전성은 다름 함수형 언어에서는 볼 수 없는 특징이다. 따라서 JS 개발자는 꼭 기억해 두어야 한다. 이런 JS 기반인 리액트의 함수형 프로그래민 모델에서도 이런 언어적 한계를 뛰어 넘을 수 없다. 따라서 얕은 비교만 사용해서 비교를 수행해 구현한다.
