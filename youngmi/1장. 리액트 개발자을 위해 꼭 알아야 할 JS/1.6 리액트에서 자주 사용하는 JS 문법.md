## ✨리액트에서 자주 사용하는 JS 문법

### 구조 분해 할당(Destructuring assignment)

배열 또는 객체의 값을 말 그대로 분해하여 별다른 선언 없이 개별 변수에 즉시 할당하는 법

#### 🟡 배열 구조 분해 할당

- 객체 구조 분해 할당과 달리 자유롭게 이름을 선언할 수 있다.
  - 때문에 `useState` 는 이 배열 구조 분해 할당을 쓴다고 추축할 수 있다.
- `,` 의 위치에 따라 값이 결정된다.
  - `[firts, , , , fifth]` 와 같이 생략할 수 있지만, 실수를 유발할 가능성이 높아지기 때문에 작은 배열에만 사용하는 것이 좋다.
- 기본 값도 선언할 수 있다.
  - 기본 값 선언 시 주의점: 반드시 값이 `undefined` 일 때만 기본값이 사용된다. (`null`, `0`, `''`은 X)
- 특정 값 이후 값을 다시 배열로 선언하고 싶으면 전개 연산자를 사용할 수 있다.
  - 이는 어디서부터 어디까지 할당할지 예측할 수 없기 때문에 뒤쪽에서만 가능하다.

#### 🟡 객체 구조 분해 할당

- 배열과 달리 객체 내부 이름으로 꺼내온다.
- 새로운 이름으로 다시 할당하는 것도 가능하다.
  ```js
  const object = { a: 1, b: 1 };
  const { a: first, b: second } = object;
  ```
- 배열과 마찬가지로 기본값을 주는 것도 가능하다.
- 단순히 값으로 꺼내오는 것이 아니라 변수에 있는 값으로 꺼내오는 **계산된 속성 이름** 방식을 사용하는 것도 가능하다.

  ```js
  const key = "a";
  const object = { a: 1, b: 1 };

  const { [key]: a } = object;
  console.log(a); // 1
  ```

  - 계산된 속성 이름 방식을 사용할 때는 반드시 이름을 선언, 즉 **네이밍**이 필요하다. (안할 시 계산된 이름인 `[key]` 로 값을 꺼내기만 했을 뿐 어느 변수명으로 할당할지 알 수 없기 때문에 error가 뜬다.)

- 배열과 마찬가지로 전개연산자 사용이 가능하다. (주의점도 동일)

> 바벨로 트랜스파일링 시 배열보다 객체가 더 복잡해서 번들링의 크기가 크다. 따라서 개발 환경이 ES5를 고려하며 객체 구조 분해 할당을 자주 사용하지 않는다면 꼭 사용해야 할지 검토해야 한다.

### 전개 구문

배열이나 객체, 문자열과 같이 순회할 수 있는 값에 대해 전개하여 간결하게 사용 가능하게 하는 구문

#### 🟡 배열의 전개 구문

- 배열의 합성을 간단하게 할 수 있도록 해준다. (이전에는 push나 concat, splice 등을 사용해서 합성했었다.)
- 원본 배열에 영향을 미치지 않고 복사할 수 있다.

#### 🟡 객체의 전개 구문

- 배열과 마찬가지로 객체 생성 시 사용 가능하며 합성에 있어서 편리함을 준다.
- 한가지 유의할 점은 순서!

  - 전개 구문 이후 값을 할당할 경우 전개 구문에 있는 값을 수정하게 되지만
    <br/>값을 할당하고 전개 구문을 할 경우 전개 구문에 있는 값을 받아들이게 된다.

  ```js
  const obj = { a: 1, b: 1, c: 1, d: 1, e: 1 };

  const spreadObj1 = { ...obj, c: 10 }; // { a: 1, b: 1, c: 10, d: 1, e: 1 }
  const spreadObj2 = { c: 10, ...obj }; // { a: 1, b: 1, c: 1, d: 1, e: 1 }
  ```

> 전개 구문 역시 배열은 트랜스파일링이 간단하지만 객체의 경우 코드가 커지므로 사용시 주의해야 한다.

### 객체 초기자

객체를 선언할 때 객체에 넣고자 하는 키와 값을 지닌 변수가 이미 존재한다면 해당 값을 간결하게 넣어줄 수 있는 방식이다.

```js
const a = 1;
const b = 2;
const obj = {
  a,
  b,
};
console.log(obj); // { a: 1, b: 2 }
```

### Array 프로토타입의 메서드: map, filter, reduce, forEach

map, filter, reduce는 배열 관련 메서드로 JSX 내부에서 배열을 조작하여 바로 원하는 JSX를 반환하는 특성상 매우 자주 쓰인다.
<br/> 👉 이 메서드들은 원본 배열 값을 건드리지 않고 새로운 값을 만들어 사용하기 때문에 안전하다.
<br/>또한 map, filter, reduce, forEach 는 모두 ES5 부터 있어 왔기 때문에 트랜스파일이나 폴리필 없이도 부담없이 사용가능하다.

#### 🟡 Array.prototype.map

- 인수로 전달받은 배열과 똑같은 길이의 새로운 배열을 반환한다.
- 배열의 각 아이템을 순회하면서 각 아이템을 콜백으로 연산한 결과들로 구성된 새로운 배열을 만들 수 있다.
- 리액트에서는 주로 특정 배열을 기반으로 어떤 리액트 요소를 반환하고자 할 때 사용한다.

#### 🟡 Array.prototype.filter

- 콜백함수를 인자로 받는데 이 콜백 함수에서 truthy 조건을 만족하는 경우만 해당 원소를 반환하는 메서드
- 즉 기존 배열에 대해 어떤한 조건을 만족하는 새로운 배열 반환 시 쓰인다.

#### 🟡 Array.prototype.reduce

- 콜백 함수와 함께 초깃값을 인수로 받는 메서드로, 이 초깃값에 따라 배열이나 객체 또는 그 이외 다른 무언가를 반환한다.
- reducer 콜백함수를 실행하고, 이를 초깃값에 누적해 결과를 반환한다.
- reducer 콜백함수의 첫번째 인수는 초깃값의 현재값, 두번째는 현재 배열 아이템이다.
- filter와 map을 같이 써서 reduce 처럼 구현할 수도 있다. 이는 가독성이 더 좋지만 같은 배열에 대해 두번 순환해야 한다.

```js
const arr = [1, 2, 3, 4, 5];
const result = arr.filter((item) => item % 2 === 0).map((item) => item * 100);
const result = arr.reduce((result, item) => {
  if (item % 2 === 0) {
    result.push(item * 100);
  }
  return result;
}, []);
```

#### 🟡 Array.prototype.forEach

- 콜백 함수를 받아 배열을 순회하면서 단순히 그 콜백 함수를 실행하기만 하는 메서드
- forEach의 주의점은 반환되는 결과값이 없다는 것이다. 반환시 undefined가 된다. 또 실행되는 순간 에러를 던지거나 프로세스를 종료하지 않는 이상 멈출 수 없다. 즉, break나 return, 그 무엇을 사용해도 순회를 멈추지 않는다.
  <br/>따라서 작성과 실행 전에 최적화 가능성이 있는지 반드시 검토해 볼 것!
